# Updated FSM Package Implementation Plan

## Overview
This updated implementation plan incorporates the design clarifications from use case analysis, particularly the data handling strategies, resource management system, and streaming capabilities. The plan prioritizes practical implementation based on validated use cases.

## Key Updates from Original Plan

### Major Additions
1. **Data Operation Modes** (COPY, REFERENCE, DIRECT)
2. **Resource Management System** as first-class component
3. **Native Streaming Support** with chunking
4. **Transaction Management** strategies
5. **Simplified API** for common use cases

### Priority Changes
- Resource management moved earlier (Phase 2)
- Streaming support moved earlier (Phase 3)
- Data modes integrated throughout phases
- Configuration simplified based on use cases

## Development Phases

### Phase 1: Core Foundation with Data Modes (Week 1-2) âœ… COMPLETED
Establish the basic FSM structure with data handling strategies from the start.

**Status**: Completed on 2025-09-05
- All components implemented and tested
- 104 tests passing with 95% code coverage

#### Checklist:
- [x] **Project Setup**
  - [x] Create package directory structure
  - [x] Configure pyproject.toml with dependencies
  - [x] Set up testing framework (pytest)
  - [x] Configure linting and formatting (ruff, black)
  - [x] Create initial __init__.py files

- [x] **Data Mode System** (`core/data_modes.py`) **[NEW]**
  - [x] Define DataMode enum (COPY, REFERENCE, DIRECT)
  - [x] Implement DataHandler abstract base class
  - [x] Implement CopyModeHandler
    - [x] Deep copy on state entry
    - [x] Isolated data modifications
    - [x] Explicit commit mechanism
  - [x] Implement ReferenceModeHandler
    - [x] Lazy loading strategy
    - [x] Optimistic locking
    - [x] Reference resolution
  - [x] Implement DirectModeHandler
    - [x] In-place modifications
    - [x] Single-threaded enforcement
  - [x] Create unit tests for each mode

- [x] **Transaction Management** (`core/transactions.py`) **[NEW]**
  - [x] Define TransactionStrategy enum
  - [x] Implement SingleTransaction strategy
  - [x] Implement BatchTransaction strategy
    - [x] Configurable batch size
    - [x] Staging support
    - [x] Commit triggers
  - [x] Implement ManualTransaction strategy
  - [x] Create transaction context manager
  - [x] Add unit tests

- [x] **Base Interfaces** (`functions/base.py`)
  - [x] Define IValidationFunction interface
  - [x] Define ITransformFunction interface
  - [x] Define IStateTestFunction interface
  - [x] Define IEndStateTestFunction interface
  - [x] Define IResource interface **[NEW]**
  - [x] Create base exception classes
  - [x] Add type hints and documentation

- [x] **Core Data Models** (`core/state.py`)
  - [x] Implement StateDefinition class
    - [x] Name and metadata properties
    - [x] Schema definition using dataknobs_data.Field
    - [x] Resource requirements **[NEW]**
    - [x] Data mode preferences **[NEW]**
    - [x] Start/end state flags
    - [x] Function references
  - [x] Implement StateInstance class
    - [x] Unique ID generation
    - [x] Data storage with mode support **[UPDATED]**
    - [x] Transaction participation **[NEW]**
    - [x] Resource access context **[NEW]**
    - [x] Status tracking
    - [x] Arc execution history
  - [x] Add validation methods
  - [x] Create unit tests

### Phase 2: Resource Management System (Week 2-3) **[MOVED UP]**
Implement resource management before networks to support use cases.

#### Checklist:
- [ ] **Resource Manager Core** (`resources/manager.py`) **[NEW]**
  - [ ] Implement ResourceManager class
    - [ ] Resource registration
    - [ ] Lifecycle management
    - [ ] Health monitoring
    - [ ] Connection pooling
  - [ ] Define resource configuration schema
  - [ ] Implement resource acquisition/release
  - [ ] Add timeout and retry logic
  - [ ] Create unit tests

- [ ] **Database Resource** (`resources/database.py`) **[NEW]**
  - [ ] Implement DatabaseResource class
    - [ ] Connection pooling
    - [ ] Transaction support
    - [ ] Query execution
    - [ ] Result streaming
  - [ ] Support multiple backends via dataknobs_data
  - [ ] Add connection health checks
  - [ ] Create integration tests

- [ ] **File System Resource** (`resources/filesystem.py`) **[NEW]**
  - [ ] Implement FileSystemResource class
    - [ ] File reading/writing
    - [ ] Streaming support
    - [ ] Directory operations
    - [ ] Temporary file handling
  - [ ] Add file locking support
  - [ ] Implement buffering strategies
  - [ ] Create unit tests

- [ ] **HTTP Service Resource** (`resources/http.py`) **[NEW]**
  - [ ] Implement HTTPServiceResource class
    - [ ] Session management
    - [ ] Request/response handling
    - [ ] Retry logic
    - [ ] Rate limiting
  - [ ] Add authentication support
  - [ ] Implement circuit breaker
  - [ ] Create unit tests

- [ ] **LLM Resource** (`resources/llm.py`) **[NEW]**
  - [ ] Implement LLMResource class
    - [ ] Model configuration
    - [ ] Prompt handling
    - [ ] Response streaming
    - [ ] Token management
  - [ ] Support multiple providers
  - [ ] Add caching layer
  - [ ] Create integration tests

- [ ] **Vector Store Resource** (`resources/vector_store.py`) **[NEW]**
  - [ ] Implement VectorStoreResource class
    - [ ] Connection management
    - [ ] Vector operations
    - [ ] Similarity search
    - [ ] Metadata handling
  - [ ] Support multiple backends
  - [ ] Add batching support
  - [ ] Create integration tests

### Phase 3: Streaming and Network Implementation (Week 3-4) **[UPDATED]**
Build streaming support early to validate large data handling.

#### Checklist:
- [ ] **Streaming Core** (`streaming/core.py`) **[MOVED UP]**
  - [ ] Implement StreamConfig class
    - [ ] Chunk size configuration
    - [ ] Parallelism settings
    - [ ] Memory limits
    - [ ] Backpressure handling
  - [ ] Define IStreamSource interface
  - [ ] Define IStreamSink interface
  - [ ] Create stream context manager
  - [ ] Add unit tests

- [ ] **File Streaming** (`streaming/file_stream.py`) **[NEW]**
  - [ ] Implement FileStreamSource
    - [ ] Line-based reading
    - [ ] Format detection (JSON, CSV, etc.)
    - [ ] Compression support
    - [ ] Progress tracking
  - [ ] Implement FileStreamSink
    - [ ] Buffered writing
    - [ ] Format serialization
    - [ ] Atomic writes
  - [ ] Create performance tests

- [ ] **Database Streaming** (`streaming/db_stream.py`) **[NEW]**
  - [ ] Implement DatabaseStreamSource
    - [ ] Cursor-based iteration
    - [ ] Batch fetching
    - [ ] Memory management
  - [ ] Implement DatabaseStreamSink
    - [ ] Batch inserts
    - [ ] Upsert support
    - [ ] Transaction batching
  - [ ] Create integration tests

- [ ] **State Network** (`core/network.py`)
  - [ ] Implement StateNetwork class
    - [ ] Network name/label
    - [ ] State collection management
    - [ ] Arc collection management
    - [ ] Resource requirements aggregation **[NEW]**
    - [ ] Streaming support flags **[NEW]**
  - [ ] Add methods for:
    - [ ] Adding/removing states
    - [ ] Adding/removing arcs
    - [ ] Validating network consistency
    - [ ] Resource dependency analysis **[NEW]**
  - [ ] Create unit tests

- [ ] **Arc Implementation** (`core/arc.py`)
  - [ ] Implement ArcDefinition class
    - [ ] Target state reference
    - [ ] Pre-test function reference
    - [ ] Transform function reference
    - [ ] Resource requirements **[NEW]**
  - [ ] Implement PushArc subclass
    - [ ] Target network reference
    - [ ] Return state reference
    - [ ] Data isolation mode **[NEW]**
  - [ ] Implement ArcExecution class
    - [ ] Execute with resource context **[NEW]**
    - [ ] Stream-aware execution **[NEW]**
    - [ ] Transaction participation **[NEW]**
  - [ ] Create unit tests

### Phase 4: Execution Engine with Modes (Week 4-5) **[UPDATED]**
Implement execution engine with full support for data modes and resources.

#### Checklist:
- [ ] **Execution Context** (`execution/context.py`)
  - [ ] Implement ExecutionContext class
    - [ ] Data mode configuration **[NEW]**
    - [ ] Transaction management **[NEW]**
    - [ ] Resource allocation **[NEW]**
    - [ ] Stream coordination **[NEW]**
    - [ ] Current state tracking
    - [ ] Network stack (for push operations)
  - [ ] Add context isolation per mode
  - [ ] Support for parallel execution paths
  - [ ] Create unit tests

- [ ] **Execution Engine** (`execution/engine.py`)
  - [ ] Implement ExecutionEngine class
    - [ ] Mode-aware execution **[NEW]**
    - [ ] Resource-aware scheduling **[NEW]**
    - [ ] Stream processing support **[NEW]**
    - [ ] Execute single transition
    - [ ] Handle branching paths
    - [ ] Manage push/pop for network calls
  - [ ] Add execution strategies:
    - [ ] Depth-first traversal
    - [ ] Breadth-first traversal
    - [ ] Resource-optimized traversal **[NEW]**
    - [ ] Stream-optimized traversal **[NEW]**
  - [ ] Implement error handling with retry
  - [ ] Add execution hooks/callbacks
  - [ ] Create comprehensive tests

- [ ] **Batch Executor** (`execution/batch.py`) **[NEW]**
  - [ ] Implement BatchExecutor class
    - [ ] Parallel record processing
    - [ ] Resource pooling
    - [ ] Progress tracking
    - [ ] Error aggregation
  - [ ] Add batching strategies
  - [ ] Implement result collection
  - [ ] Create performance benchmarks

- [ ] **Stream Executor** (`execution/stream.py`) **[NEW]**
  - [ ] Implement StreamExecutor class
    - [ ] Chunk-based processing
    - [ ] Pipeline coordination
    - [ ] Memory management
    - [ ] Backpressure handling
  - [ ] Add stream transformations
  - [ ] Implement progress reporting
  - [ ] Create performance tests

### Phase 5: Configuration and Building (Week 5-6) **[UPDATED]**
Simplified configuration based on use case patterns.

#### Checklist:
- [ ] **Configuration Schema** (`config/schema.py`)
  - [ ] Define configuration schema using pydantic
    - [ ] Data mode configuration **[NEW]**
    - [ ] Transaction configuration **[NEW]**
    - [ ] Resource definitions **[NEW]**
    - [ ] Streaming configuration **[NEW]**
    - [ ] FSM definition
    - [ ] Network definition
    - [ ] State definition
    - [ ] Arc definition
  - [ ] Add use case templates **[NEW]**
  - [ ] Create validation rules
  - [ ] Generate JSON Schema
  - [ ] Create unit tests

- [ ] **Configuration Loader** (`config/loader.py`)
  - [ ] Implement ConfigLoader class
    - [ ] Load from file
    - [ ] Load from dictionary
    - [ ] Environment variable expansion
    - [ ] Resource reference resolution **[NEW]**
  - [ ] Add template support **[NEW]**
  - [ ] Support for includes/imports
  - [ ] Create unit tests

- [ ] **FSM Builder** (`config/builder.py`)
  - [ ] Implement FSMBuilder class
    - [ ] Build FSM from configuration
    - [ ] Resource registration **[NEW]**
    - [ ] Mode configuration **[NEW]**
    - [ ] Function resolution
    - [ ] Validate completeness
  - [ ] Add builder patterns for common use cases **[NEW]**
  - [ ] Support for custom function registration
  - [ ] Create integration tests

- [ ] **Built-in Functions Library** (`functions/library/`)
  - [ ] Common Validators (`validators.py`)
    - [ ] RequiredFieldsValidator
    - [ ] SchemaValidator
    - [ ] RangeValidator
    - [ ] PatternValidator
  - [ ] Common Transformers (`transformers.py`)
    - [ ] FieldMapper
    - [ ] ValueNormalizer
    - [ ] TypeConverter
    - [ ] DataEnricher
  - [ ] Database Functions (`database.py`) **[NEW]**
    - [ ] DatabaseFetch
    - [ ] DatabaseUpsert
    - [ ] BatchCommit
  - [ ] Stream Functions (`streaming.py`) **[NEW]**
    - [ ] ChunkReader
    - [ ] RecordParser
    - [ ] FileAppender
  - [ ] LLM Functions (`llm.py`) **[NEW]**
    - [ ] PromptBuilder
    - [ ] LLMCaller
    - [ ] ResponseValidator
  - [ ] Create comprehensive tests

### Phase 6: History and Storage (Week 6-7) **[UPDATED]**
Implement history tracking with mode-aware storage.

#### Checklist:
- [ ] **History Tracking** (`execution/history.py`)
  - [ ] Implement ExecutionHistory class
    - [ ] Use dataknobs_structures.Tree
    - [ ] Mode-aware storage **[NEW]**
    - [ ] Resource usage tracking **[NEW]**
    - [ ] Stream progress tracking **[NEW]**
    - [ ] Track state instances
    - [ ] Track arc executions
    - [ ] Record timestamps and metrics
  - [ ] Add methods for:
    - [ ] Adding execution steps
    - [ ] Querying paths
    - [ ] Pruning strategies based on mode **[NEW]**
    - [ ] Serializing history
    - [ ] Generating reports
  - [ ] Create visualization methods
  - [ ] Create unit tests

- [ ] **Storage Interface** (`storage/base.py`)
  - [ ] Define IHistoryStorage interface
  - [ ] Define storage configuration
  - [ ] Add mode-specific storage strategies **[NEW]**
  - [ ] Create storage factory
  - [ ] Add unit tests

- [ ] **Memory Storage** (`storage/memory.py`)
  - [ ] Implement InMemoryStorage class
  - [ ] Add size limits per mode **[NEW]**
  - [ ] Implement LRU eviction
  - [ ] Add compression for REFERENCE mode **[NEW]**
  - [ ] Create unit tests

- [ ] **Database Storage** (`storage/database.py`)
  - [ ] Implement DatabaseStorage class
  - [ ] Use dataknobs_data abstractions
  - [ ] Add mode-specific schemas **[NEW]**
  - [ ] Support for PostgreSQL, SQLite, MongoDB
  - [ ] Add indexing for queries
  - [ ] Implement partitioning for streams **[NEW]**
  - [ ] Create integration tests

- [ ] **File Storage** (`storage/file.py`)
  - [ ] Implement FileStorage class
  - [ ] Support for JSON/YAML serialization
  - [ ] Add streaming write support **[NEW]**
  - [ ] Implement rotation policies
  - [ ] Add compression support
  - [ ] Create unit tests

### Phase 7: API and Integration (Week 7-8) **[NEW PHASE]**
Create simplified APIs and integration patterns.

#### Checklist:
- [ ] **Simple API** (`api/simple.py`) **[NEW]**
  - [ ] Implement simplified FSM class
    - [ ] process() for single records
    - [ ] process_batch() for collections
    - [ ] process_stream() for large data
  - [ ] Add convenience methods
  - [ ] Create quick-start examples
  - [ ] Write API documentation

- [ ] **Advanced API** (`api/advanced.py`) **[NEW]**
  - [ ] Implement full-control interfaces
    - [ ] Custom executors
    - [ ] Resource management
    - [ ] Transaction control
    - [ ] Stream coordination
  - [ ] Add monitoring hooks
  - [ ] Create advanced examples
  - [ ] Write detailed documentation

- [ ] **Integration Patterns** (`patterns/`) **[NEW]**
  - [ ] Database ETL pattern
  - [ ] File processing pattern
  - [ ] API orchestration pattern
  - [ ] LLM workflow pattern
  - [ ] Error recovery pattern
  - [ ] Create pattern templates
  - [ ] Write pattern guides

- [ ] **CLI Tool** (`cli/`) **[NEW]**
  - [ ] FSM validation command
  - [ ] Execution command
  - [ ] History inspection
  - [ ] Resource management
  - [ ] Performance profiling
  - [ ] Create user documentation

### Phase 8: Testing and Documentation (Week 8-9) **[EXTENDED]**
Comprehensive testing with focus on modes and resources.

#### Checklist:
- [ ] **Unit Tests**
  - [ ] Test all data modes independently
  - [ ] Test resource lifecycle
  - [ ] Test streaming components
  - [ ] Test transaction strategies
  - [ ] Achieve >90% code coverage
  - [ ] Test all error conditions
  - [ ] Test edge cases

- [ ] **Integration Tests**
  - [ ] Database processing scenarios
  - [ ] File streaming scenarios
  - [ ] LLM workflow scenarios
  - [ ] Multi-resource coordination
  - [ ] Mode switching tests
  - [ ] Transaction rollback tests
  - [ ] End-to-end use cases

- [ ] **Performance Tests** **[NEW]**
  - [ ] Benchmark data modes
  - [ ] Measure resource overhead
  - [ ] Test streaming throughput
  - [ ] Profile memory usage
  - [ ] Load testing
  - [ ] Create performance reports

- [ ] **Example Implementations** (`examples/`)
  - [ ] Database ETL pipeline
    - [ ] COPY mode with batching
    - [ ] Transaction management
    - [ ] Error recovery
  - [ ] Large file processor
    - [ ] REFERENCE mode streaming
    - [ ] Chunk processing
    - [ ] Progress tracking
  - [ ] LLM conversation system
    - [ ] Multi-resource coordination
    - [ ] Dynamic path selection
    - [ ] Retry and fallback
  - [ ] Simple data validator
    - [ ] DIRECT mode for speed
    - [ ] Schema validation
    - [ ] Quick processing

- [ ] **Documentation**
  - [ ] Quick Start Guide
  - [ ] Data Modes Guide **[NEW]**
  - [ ] Resource Management Guide **[NEW]**
  - [ ] Streaming Guide **[NEW]**
  - [ ] Configuration Reference
  - [ ] API Reference
  - [ ] Pattern Catalog **[NEW]**
  - [ ] Performance Tuning Guide
  - [ ] Migration Guide

### Phase 9: Optimization and Polish (Week 9-10) **[NEW PHASE]**
Performance optimization and production readiness.

#### Checklist:
- [ ] **Performance Optimizations**
  - [ ] Implement caching strategies
    - [ ] Function result caching
    - [ ] Resource connection caching
    - [ ] Validation caching
  - [ ] Optimize data mode switching
  - [ ] Improve streaming throughput
  - [ ] Reduce memory footprint
  - [ ] Add JIT compilation hooks

- [ ] **Production Features**
  - [ ] Monitoring and metrics
    - [ ] Prometheus integration
    - [ ] Custom metrics
    - [ ] Performance dashboards
  - [ ] Logging improvements
    - [ ] Structured logging
    - [ ] Log levels per component
    - [ ] Audit trail
  - [ ] Health checks
    - [ ] Resource health
    - [ ] System health
    - [ ] Readiness probes

- [ ] **Developer Experience**
  - [ ] Improved error messages
  - [ ] Debugging tools
  - [ ] Configuration validation
  - [ ] Type stub generation
  - [ ] IDE integrations

## Resource Requirements (Updated)

### Team Composition
- **Lead Developer**: Architecture, data modes, core implementation
- **Resource Developer**: Resource management system **[NEW]**
- **Streaming Developer**: Streaming implementation **[NEW]**
- **Backend Developer**: Storage and execution engine
- **Integration Developer**: DataKnobs package integration
- **Test Engineer**: Testing framework and test cases
- **Documentation Writer**: User guides and API docs

### Tools and Infrastructure
- Python 3.10+
- Development environment with all DataKnobs packages
- Test databases (PostgreSQL, MongoDB)
- Mock LLM services for testing
- Performance testing environment
- CI/CD pipeline with matrix testing
- Documentation build system

## Risk Mitigation (Updated)

### Technical Risks
1. **Mode Switching Complexity**
   - Mitigation: Clear mode boundaries, comprehensive testing
   
2. **Resource Leak Potential**
   - Mitigation: Context managers, automatic cleanup, health monitoring

3. **Streaming Memory Issues**
   - Mitigation: Bounded buffers, backpressure, monitoring

4. **Transaction Consistency**
   - Mitigation: Two-phase commit, rollback support, testing

### Schedule Risks
1. **Resource Integration Complexity**
   - Mitigation: Start with database, add others incrementally

2. **Streaming Implementation**
   - Mitigation: Use proven patterns, leverage dataknobs_data

3. **Performance Requirements**
   - Mitigation: Early benchmarking, iterative optimization

## Success Criteria (Updated)

### Functional
- [ ] All three data modes working correctly
- [ ] Core resources implemented (Database, File, HTTP, LLM, Vector)
- [ ] Streaming support for large data
- [ ] Transaction management working
- [ ] All use cases implementable

### Non-Functional
- [ ] COPY mode overhead <10% vs direct processing
- [ ] Streaming can handle files >10GB
- [ ] Resource pooling reduces connection overhead by >50%
- [ ] Memory usage bounded in all modes
- [ ] Code coverage >90%

### Deliverables
- [ ] Source code in packages/fsm
- [ ] Comprehensive test suite
- [ ] Documentation for all features
- [ ] Example implementations
- [ ] Performance benchmarks
- [ ] Pattern library

## Implementation Priority (Based on Use Cases)

### Critical Path (Must Have)
1. Data modes (COPY as default)
2. Basic resource management (Database)
3. Core FSM execution
4. Configuration loading
5. Simple API

### High Priority (Should Have)
1. Streaming support
2. Transaction management
3. LLM and Vector resources
4. Batch processing
5. Error recovery

### Medium Priority (Nice to Have)
1. Advanced storage backends
2. Performance optimizations
3. CLI tool
4. Monitoring integration
5. Pattern library

### Low Priority (Future)
1. Distributed execution
2. ML integration
3. Visual designer
4. Advanced caching

## Development Guidelines (Updated)

### Code Style
- Follow PEP 8 guidelines
- Use type hints throughout
- Maintain comprehensive docstrings
- Keep functions focused and testable
- Use async/await for I/O operations

### Testing Strategy
- Test each data mode independently
- Mock external resources
- Use property-based testing for complex logic
- Benchmark performance regularly
- Test failure scenarios thoroughly

### Documentation
- Document data mode selection criteria
- Provide resource configuration examples
- Include streaming best practices
- Show transaction patterns
- Update examples for each use case

## Quick Start Implementation Order

For rapid prototype and validation:

1. **Week 1**: Core + COPY mode + Database resource
2. **Week 2**: Basic execution + Simple API
3. **Week 3**: Configuration + One complete use case
4. **Week 4**: Testing + Documentation

This allows demonstrating value quickly while building toward full implementation.